---
title: 冒泡排序
categories:
  - 算法
tags:
  - 排序
  - 冒泡
  - 算法
comments: false
date: 2016-05-19 20:52:36
updated: 2016-05-19 20:52:36
img:
---
# 冒泡排序
## 概述
- 重复地走访过要排序的元素列，依次比较两个相邻的元素，如果他们的顺序错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。
- 这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。

## 步骤
- 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
- 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。
- 针对所有的元素重复以上的步骤，除了最后一个。
- 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

## 代码实现
### C冒泡排序
```
void sort_mp_c (elemType arr[], int len) {
    elemType temp;
    int i, j;
    for (i=0; i<len-1; i++) 
        for (j=0; j<len-1-i; j++) { 
            if (arr[j] > arr[j+1]) {  
                temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
}
```

### Python 冒泡排序
```
def sort_mp_py(v_list):
    for i in range(len(v_list)-1):
	for j in range(len(v_list)-i-1):
	    if v_list[j] > v_list[j+1]:
		v_list[j],v_list[j+1] = v_list[j+1],v_list[j]
	    else:
	  	continue
    return v_list
```

## 性能分析
### 时间复杂度
平均时间复杂度为O(n^2)
### 算法稳定性
- 冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。
- 如果两个元素相等，是不会再交换的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。
